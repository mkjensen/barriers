/**
 * Copyright 2010-2011 Martin Kamp Jensen
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.martinkampjensen.thesis.util.gromacs;

import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;
import java.util.NoSuchElementException;

import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;

/**
 * Reads atom coordinates of conformations (frames) in an XTC trajectory. Uses
 * the GROMACS XTC Library (xdrfile) via Java Native Access (JNA).
 * <p>
 * Note that this implementation is not synchronized and that this class has not
 * been prepared to handle the existence of more than one instance at a time.
 * <p>
 * libxdrfile.[so,dylib] or xdrfile.dll must be in
 * <code>jna.library.path</code>. Tested using XTC files generated by GROMACS
 * 4.5.4.
 * 
 * @see <a href="http://www.gromacs.org">GROMACS</a>
 * @see <a href="https://github.com/twall/jna">Java Native Access</a>
 */
public final class XtcReader
implements Closeable, Iterator<double[][]>, Iterable<double[][]>
{
	/**
	 * Name of the native library. Will be libLIBRARY_NAME.so on Linux,
	 * libLIBRARY_NAME.dylib on Mac OS X, and LIBRARY_NAME.dll on Windows.
	 */
	private static final String LIBRARY_NAME = "xdrfile";

	/**
	 * <code>exdrOK</code> from xdrfile.h.
	 */
	private static final int STATUS_SUCCESS = 0;

	/**
	 * <code>exdrENDOFFILE</code> from xdrfile.h.
	 */
	private static final int STATUS_END = 11;

	/**
	 * From xdrfile.h, <code>"r"</code> for reading.
	 */
	private static final String MODE_READ = "r";

	/**
	 * Number of coordinates per point/atom.
	 */
	private static final int DIMENSIONS = 3;

	private final String _xdrPath;
	private final Pointer _xdrPointer;
	private final int _nAtoms;
	private final IntByReference _frameStep;
	private final FloatByReference _frameTime;
	private final float[] _frameBox;
	private final float[] _frameX;
	private final FloatByReference _framePrec;
	private boolean _isClosed;
	private boolean _hasNext;
	private int _nConformations;

	public XtcReader(File trajectory)
	throws FileNotFoundException, IOException
	{
		if(!trajectory.exists() || !trajectory.isFile()) {
			throw new FileNotFoundException("trajectory does not exist or is "
					+ "not a file");
		}

		Native.register(LIBRARY_NAME);

		_xdrPath = trajectory.getAbsolutePath();
		_xdrPointer = xdrfile_open(_xdrPath, MODE_READ);

		if(_xdrPointer == null) {
			throw new IOException("Unknown error when trying to open "
					+ "trajectory");
		}

		final IntByReference nAtomsRef = new IntByReference();
		final int statusCode = read_xtc_natoms(_xdrPath, nAtomsRef);

		if(statusCode != STATUS_SUCCESS) {
			close();
			throw new IOException("Error " + statusCode + " when trying to "
					+ "read number of atoms");
		}

		_nAtoms = nAtomsRef.getValue();
		_frameStep = new IntByReference();
		_frameTime = new FloatByReference();
		_frameBox = new float[DIMENSIONS * DIMENSIONS];
		_frameX = new float[_nAtoms * DIMENSIONS];
		_framePrec = new FloatByReference();

		// Prefetch first conformation.
		readConformation();

		_isClosed = false;
		_hasNext = true;
		_nConformations = 0;
	}

	@Override
	public void close() throws IOException
	{
		if(_isClosed) {
			return;
		}
		else {
			_isClosed = true;
		}

		final int statusCode = xdrfile_close(_xdrPointer);

		Native.unregister();

		if(statusCode != STATUS_SUCCESS) {
			throw new IOException("Error " + statusCode + " when trying to "
					+ "close trajectory");
		}
	}

	@Override
	public boolean hasNext()
	{
		return _hasNext;
	}

	/**
	 * Reads and returns the coordinates of the atoms of the next conformation
	 * (frame) of the trajectory. The coordinates are in angstrom.
	 * 
	 * @return an array containing the atom coordinates.
	 * @throws IllegalStateException if {@link #close()} has been called.
	 * @throws NoSuchElementException if there are no more conformations. This
	 *         means that {@link #hasNext()} would have returned
	 *         <code>false</code> immediately before this method was called or
	 *         that an {@link IOException} occurred.
	 */
	public double[][] next()
	{
		final double[][] coordinates = createCoordinatesArray();

		try {
			next(coordinates);
		}
		catch(IOException e) {
			final NoSuchElementException nsee = new NoSuchElementException();
			nsee.initCause(e);
			throw nsee;
		}

		return coordinates;
	}

	/**
	 * @throws UnsupportedOperationException always.
	 */
	@Override
	public void remove()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public Iterator<double[][]> iterator()
	{
		return this;
	}

	/**
	 * Reads the coordinates of the atoms of the next conformation (frame) of
	 * the trajectory and fills them into an array. The coordinates are in
	 * angstrom.
	 * 
	 * @param coordinates an array to fill with the atom coordinates.
	 * @throws IllegalStateException if {@link #close()} has been called.
	 * @throws IOException if an I/O error occurs while reading from the
	 *         trajectory.
	 * @throws NoSuchElementException if there are no more conformations. This
	 *         means that {@link #hasNext()} would have returned
	 *         <code>false</code> immediately before this method was called.
	 * @throws NullPointerException if <code>coordinates == null</code>.
	 * @throws IndexOutOfBoundsException if <code>coordinates</code> has illegal
	 *         dimensions.
	 */
	public void next(double[][] coordinates) throws IOException
	{
		if(!_hasNext) {
			throw new NoSuchElementException();
		}

		_nConformations++;
		fillMatrix(coordinates, _frameX, _nAtoms, DIMENSIONS);
		readConformation();
	}

	/**
	 * Returns the number of atoms in each conformation (frame) of the
	 * trajectory.
	 * 
	 * @return the number of atoms. 
	 */
	public int atoms()
	{
		return _nAtoms;
	}

	/**
	 * Returns the number of conformations (frames) read.
	 * <p>
	 * When {@link #hasNext()} has returned <code>false</code>, this is the
	 * total number of conformations in the trajectory.
	 * 
	 * @return the number of frames.
	 */
	public int conformations()
	{
		return _nConformations;
	}

	/**
	 * Creates and returns an array that can be used with the
	 * {@link #next(float[][])} method.
	 * 
	 * @return the array.
	 */
	public double[][] createCoordinatesArray()
	{
		return new double[_nAtoms][DIMENSIONS];
	}

	/**
	 * This implementation calls {@link #close()}.
	 * <p>
	 * {@inheritDoc}
	 */
	@Override
	protected void finalize() throws IOException
	{
		close();
	}

	/**
	 * Converts an array of values in nm to values in angstrom.
	 * <p>
	 * <code>1 nm == 1 * 10^-9</code>, <code>1 angstrom == 1 * 10^-10</code>.
	 * 
	 * @param array the array.
	 * @see <a href="http://en.wikipedia.org/wiki/Angstrom">Angstrom</a>
	 */
	private static void fromNmToAngstrom(float[] array)
	{
		final int length = array.length;
		for(int i = 0; i < length; i++) {
			array[i] *= 10;
		}
	}

	/**
	 * Fills a matrix using an array.
	 * 
	 * @param matrix the matrix.
	 * @param array the array.
	 * @param rows the number of rows in the matrix.
	 * @param columns the number of columns in the matrix.
	 * @return the matrix.
	 * @throws NullPointerException if <code>matrix == null</code> or if
	 *         <code>array == null</code>.
	 * @throws IndexOutOfBoundsException if there is a mismatch between
	 *         <code>matrix</code>, <code>array</code>, <code>rows</code>, and
	 *         <code>columns</code>.
	 */
	private static void fillMatrix(double[][] matrix, float[] array, int rows,
			int columns)
	{
		for(int i = 0; i < rows; i++) {
			for(int j = 0; j < columns; j++) {
				matrix[i][j] = array[i * columns + j];
			}
		}
	}

	/**
	 * Checks if the state of this object is legal, that is, if {@link #close()}
	 * has not been called. If the state is illegal, an
	 * {@link IllegalStateException} is thrown.
	 * 
	 * @throws IllegalStateException if the state is illegal.
	 */
	private void checkState()
	{
		if(_isClosed) {
			throw new IllegalStateException("close() has been called");
		}
	}

	/**
	 * Reads a conformation (frame) from the trajectory.
	 * 
	 * @throws IOException if an I/O error occurs while reading from the
	 *         trajectory.
	 */
	private void readConformation() throws IOException
	{
		checkState();

		final float[] x = _frameX;
		final int statusCode = read_xtc(_xdrPointer, _nAtoms, _frameStep,
				_frameTime, _frameBox, x, _framePrec);

		if(statusCode == STATUS_SUCCESS) {
			fromNmToAngstrom(x);
		}
		else if(statusCode == STATUS_END) {
			_hasNext = false;
		}
		else {
			throw new IOException("Error " + statusCode + " when trying to "
					+ "read frame");
		}
	}

	// Direct Mapping using Java Native Access. Selected methods from xdrfile.h
	// and xdrfile_xtc.h of the GROMACS XTC Library (xdrfile).
	private native Pointer xdrfile_open(String path, String mode);
	private native int xdrfile_close(Pointer xfp);
	private native int read_xtc_natoms(String fn, IntByReference natoms);
	private native int read_xtc(Pointer xd, int natoms, IntByReference step,
			FloatByReference time, float[] box, float[] x,
			FloatByReference prec);
}
