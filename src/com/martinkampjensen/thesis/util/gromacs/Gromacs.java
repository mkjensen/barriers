/**
 * Copyright 2010-2011 Martin Kamp Jensen
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.martinkampjensen.thesis.util.gromacs;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import com.martinkampjensen.thesis.Main;
import com.martinkampjensen.thesis.StatusCode;
import com.martinkampjensen.thesis.util.Debug;
import com.martinkampjensen.thesis.util.FileHandler;
import com.martinkampjensen.thesis.util.Util;

/**
 * TODO: Document {@link Gromacs}.
 * <p>
 * Note: This class is not thread-safe.
 */
public final class Gromacs
{
	/**
	 * Relative (to application root) path to single precision evaluate script
	 * that runs GROMACS.
	 */
	private static final String RELATIVE_PATH_TO_SINGLE_PRECISION_EVALUATE =
		(Util.isWindows() ? "gromacs/evaluation/evaluate.cmd" :
		"gromacs/evaluation/evaluate");

	/**
	 * Relative (to application root) path to double precision evaluate script
	 * that runs GROMACS.
	 */
	private static final String RELATIVE_PATH_TO_DOUBLE_PRECISION_EVALUATE =
		(Util.isWindows() ? "gromacs/evaluation/evaluate_d.cmd" :
		"gromacs/evaluation/evaluate_d");

	/**
	 * Relative (to application root) path to single precision minimize script
	 * that runs GROMACS.
	 */
	private static final String RELATIVE_PATH_TO_SINGLE_PRECISION_MINIMIZE =
		"gromacs/minimization/minimize";

	/**
	 * Relative (to application root) path to double precision minimize script
	 * that runs GROMACS.
	 */
	private static final String RELATIVE_PATH_TO_DOUBLE_PRECISION_MINIMIZE =
		"gromacs/minimization/minimize_d";

	/**
	 * File name of trajectory file used to send conformations to GROMACS before
	 * evaluation and minimization.
	 */
	private static final String TRAJECTORY_FILE_NAME = "input.pdb";

	/**
	 * File name of energy file generated by GROMACS after evaluation.
	 */
	private static final String ENERGY_FILE_NAME = "output.edr";

	/**
	 * File name of conformation file used to receive a conformation from
	 * GROMACS after minimization.
	 */
	private static final String CONFORMATION_FILE_NAME = "output.pdb";

	private static Gromacs _instance;
	private final File _workingDirectory;
	private final File _topologyFile;
	private final File _trajectoryFile;
	private final File _energyFile;
	private final File _conformationFile;
	private final ProcessBuilder _evaluateProcessBuilder;
	private final ProcessBuilder _minimizeProcessBuilder;
	private final EnergyExtractor _energyExtractor;

	/**
	 * Constructs a new instance of this class that can be used to communicate
	 * with GROMACS for calculating energy values.
	 * 
	 * @param workingDirectory the directory where temporary files for
	 *        communicating with GROMACS are stored.
	 * @param moleculeFile the molecule that this instance will work with.
	 * @param topologyFile topology for the molecule.
	 * @param useDoublePrecision double precision energy values are used if and
	 *        only if <code>useDoublePrecision == true</code>. Otherwise, single
	 *        precision energy values are used.
	 * @return an instance for communicating with GROMACS.
	 */
	private Gromacs(File workingDirectory, File moleculeFile, File topologyFile,
			boolean useDoublePrecision)
	{
		if(workingDirectory == null) {
			throw new NullPointerException("workingDirectory == null");
		}
		else if(!workingDirectory.exists() && !workingDirectory.mkdirs()) {
			Main.errorExit(
					"Could not create working directory for use with GROMACS",
					StatusCode.IO);
		}
		else if(moleculeFile == null) {
			throw new NullPointerException("moleculeFile == null");
		}
		else if(!moleculeFile.exists() || !moleculeFile.isFile()) {
			Main.errorExit("moleculeFile does not exist or is not a file",
					StatusCode.IO);
		}
		else if(topologyFile != null && (!topologyFile.exists()
				|| !topologyFile.isFile())) {
			Main.errorExit("topologyFile does not exist or is not a file",
					StatusCode.IO);
		}

		final File evaluateScript = new File(".", (useDoublePrecision ?
				RELATIVE_PATH_TO_DOUBLE_PRECISION_EVALUATE :
					RELATIVE_PATH_TO_SINGLE_PRECISION_EVALUATE));

		if(!evaluateScript.exists() || !evaluateScript.isFile()) {
			Main.errorExit("evaluate script does not exist or is not a file",
					StatusCode.IO);
		}

		final File minimizeScript = new File(".", (useDoublePrecision ?
				RELATIVE_PATH_TO_DOUBLE_PRECISION_MINIMIZE :
					RELATIVE_PATH_TO_SINGLE_PRECISION_MINIMIZE));

		if(!minimizeScript.exists() || !minimizeScript.isFile()) {
			Main.errorExit("minimize script does not exist or is not a file",
					StatusCode.IO);
		}

		_workingDirectory = workingDirectory;
		_topologyFile = topologyFile;
		_trajectoryFile = new File(_workingDirectory, TRAJECTORY_FILE_NAME);
		_energyFile = new File(_workingDirectory, ENERGY_FILE_NAME);
		_conformationFile = new File(_workingDirectory, CONFORMATION_FILE_NAME);

		String[] command;
		if(Util.isWindows()) {
			// TODO: Remove Windows support :)
			// Yes, this is crazy, see e.g. http://stackoverflow.com/questions/6447258/trouble-calling-batch-file-from-java-program
			command = new String[] {
					"cmd", "/c", "start", "/wait", "cmd", "/c", "", ""
			};
		}
		else {
			command = new String[2];
		}
		command[command.length - 2] = evaluateScript.getAbsolutePath();
		command[command.length - 1] = _trajectoryFile.getAbsolutePath();

		_evaluateProcessBuilder = new ProcessBuilder(command);
		_evaluateProcessBuilder.directory(_workingDirectory);

		if(_topologyFile != null) {
			_minimizeProcessBuilder = new ProcessBuilder(
					minimizeScript.getAbsolutePath(),
					_trajectoryFile.getAbsolutePath(),
					_topologyFile.getAbsolutePath());
			_minimizeProcessBuilder.directory(_workingDirectory);
		}
		else {
			_minimizeProcessBuilder = null;
		}

		String trajectory = FileHandler.read(moleculeFile);
		final int end = trajectory.indexOf("CONECT");
		if(end != -1) {
			trajectory = trajectory.substring(0, end);
			trajectory += "TER\nENDMDL\n";
		}
		trajectory += trajectory;
		FileHandler.write(trajectory, _trajectoryFile);
		execute(_evaluateProcessBuilder);

		EnergyExtractor ee = null;
		try {
			ee = new EnergyExtractor(_energyFile);
		}
		catch (IOException e) {
			Main.errorExit(e, StatusCode.IO);
		}
		_energyExtractor = ee;

		Debug.line("Created object for communicating with %s precision GROMACS",
				(useDoublePrecision ? "double" : "single"));
	}

	public static Gromacs getInstance()
	{
		return _instance;
	}

	public static Gromacs getInstance(File moleculeFile, File topologyFile)
	{
		if(_instance != null) {
			return _instance;
		}

		// TODO: Hardcoded.
		File workingDirectory;
		if(Util.isWindows()) {
			workingDirectory = new File("G:\\");
		}
		else if(Util.isMacOs()) {
			workingDirectory = new File("/Volumes/RAM");
		}
		else {
			workingDirectory = new File("/dev/shm/mkjthesis");	
		}

		_instance = new Gromacs(workingDirectory, moleculeFile, topologyFile,
				false);

		return _instance;
	}

	public double evaluate(String trajectory)
	{
		FileHandler.write(trajectory, _trajectoryFile);
		execute(_evaluateProcessBuilder);

		try {
			return _energyExtractor.extractEnergyValue(_energyFile);
		}
		catch(IOException e) {
			Main.errorExit(e, StatusCode.IO);
			return 0d;
		}
	}

	public double[] evaluate(String trajectory, int conformations)
	{
		FileHandler.write(trajectory, _trajectoryFile);
		execute(_evaluateProcessBuilder);

		try {
			return _energyExtractor.extractEnergyValues(_energyFile,
					conformations);
		}
		catch(IOException e) {
			Main.errorExit(e, StatusCode.IO);
			return null;
		}
	}

	public String minimize(String trajectory)
	{
		if(_minimizeProcessBuilder == null) {
			throw new IllegalStateException("Minimization requires a topology");
		}

		FileHandler.write(trajectory, _trajectoryFile);
		execute(_minimizeProcessBuilder);
		return FileHandler.read(_conformationFile);
	}

	private static void execute(ProcessBuilder processBuilder)
	{
		Process process = null;

		try {
			process = processBuilder.start();

			while(true) {
				try {
					process.waitFor();
					break;
				}
				catch(InterruptedException e) {
				}
			}
		}
		catch(IOException e) {
			Main.errorExit(e, StatusCode.IO);
		}

		if(!isProcessExitSuccessful(process)) {
			printErrorAndExit(process);
		}

		process.destroy();
	}

	private static boolean isProcessExitSuccessful(Process process)
	{
		return process.exitValue() == 0;
	}

	private static void printErrorAndExit(Process process)
	{
		final BufferedReader reader = new BufferedReader(
				new InputStreamReader(process.getErrorStream()));
		final StringBuilder sb = new StringBuilder();
		String line;

		try {
			while((line = reader.readLine()) != null) {
				sb.append(line);
				sb.append('\n');
			}
		}
		catch(IOException e) {
			sb.append("\nAdditionally, an IOException was caught while ");
			sb.append("creating this error message.\n");
		}

		Main.errorExit(sb.toString(), StatusCode.GROMACS);
	}
}
